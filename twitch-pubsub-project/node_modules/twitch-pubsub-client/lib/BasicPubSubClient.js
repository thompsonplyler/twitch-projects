"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var WebSocket = require("universal-websocket-client");
var typed_event_emitter_1 = require("@d-fischer/typed-event-emitter");
var logger_1 = require("@d-fischer/logger");
var Decorators_1 = require("./Toolkit/Decorators");
/**
 * A client for the Twitch PubSub interface.
 */
var BasicPubSubClient = /** @class */ (function (_super) {
    tslib_1.__extends(BasicPubSubClient, _super);
    /**
     * Creates a new PubSub client.
     *
     * @param logLevel The level of logging to use for the PubSub client.
     */
    function BasicPubSubClient(logLevel) {
        if (logLevel === void 0) { logLevel = logger_1.LogLevel.WARNING; }
        var _this = _super.call(this) || this;
        // topic => token
        _this._topics = new Map();
        _this._connecting = false;
        _this._connected = false;
        _this._manualDisconnect = false;
        _this._initialConnect = false;
        _this._onPong = _this.registerEvent();
        _this._onResponse = _this.registerEvent();
        /**
         * Fires when a message that matches your listening topics is received.
         *
         * @eventListener
         * @param topic The name of the topic.
         * @param message The message data.
         */
        _this.onMessage = _this.registerEvent();
        /**
         * Fires when the client finishes establishing a connection to the PubSub server.
         *
         * @eventListener
         */
        _this.onConnect = _this.registerEvent();
        /**
         * Fires when the client closes its connection to the PubSub server.
         *
         * @eventListener
         * @param isError Whether the cause of the disconnection was an error. A reconnect will be attempted if this is true.
         */
        _this.onDisconnect = _this.registerEvent();
        /**
         * Fires when the client receives a pong message from the PubSub server.
         *
         * @eventListener
         * @param latency The current latency to the server, in milliseconds.
         * @param requestTimestampe The time the ping request was sent to the PubSub server.
         */
        _this.onPong = _this.registerEvent();
        _this._logger = new logger_1.default({
            name: 'twitch-pubsub-client',
            minLevel: logLevel
        });
        return _this;
    }
    /**
     * Listens to one or more topics.
     *
     * @param topics A topic or a list of topics to listen to.
     * @param accessToken An access token. Only necessary for some topics.
     */
    BasicPubSubClient.prototype.listen = function (topics, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var topics_1, topics_1_1, topic;
            var e_1, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (typeof topics === 'string') {
                            topics = [topics];
                        }
                        try {
                            for (topics_1 = tslib_1.__values(topics), topics_1_1 = topics_1.next(); !topics_1_1.done; topics_1_1 = topics_1.next()) {
                                topic = topics_1_1.value;
                                this._topics.set(topic, accessToken);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (topics_1_1 && !topics_1_1.done && (_a = topics_1.return)) _a.call(topics_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        if (!this._connected) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._sendListen(topics, accessToken)];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Removes one or more topics from the listener.
     *
     * @param topics A topic or a list of topics to not listen to anymore.
     */
    BasicPubSubClient.prototype.unlisten = function (topics) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var topics_2, topics_2_1, topic;
            var e_2, _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (typeof topics === 'string') {
                            topics = [topics];
                        }
                        try {
                            for (topics_2 = tslib_1.__values(topics), topics_2_1 = topics_2.next(); !topics_2_1.done; topics_2_1 = topics_2.next()) {
                                topic = topics_2_1.value;
                                this._topics.delete(topic);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (topics_2_1 && !topics_2_1.done && (_a = topics_2.return)) _a.call(topics_2);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        if (!this._connected) return [3 /*break*/, 2];
                        return [4 /*yield*/, this._sendUnlisten(topics)];
                    case 1:
                        _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Connects to the PubSub interface.
     */
    BasicPubSubClient.prototype.connect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                this._logger.info('Connecting...');
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (_this._connected) {
                            resolve();
                            return;
                        }
                        _this._connecting = true;
                        _this._initialConnect = true;
                        _this._socket = new WebSocket('wss://pubsub-edge.twitch.tv');
                        _this._socket.onopen = function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        this._connected = true;
                                        this._connecting = false;
                                        this._initialConnect = false;
                                        this._retryDelayGenerator = undefined;
                                        this._startPingCheckTimer();
                                        this._logger.info('Connection established');
                                        return [4 /*yield*/, this._resendListens()];
                                    case 1:
                                        _a.sent();
                                        if (this._topics.size) {
                                            this._logger.info('Listened to previously registered topics');
                                            this._logger.debug2("Previously registered topics: " + Array.from(this._topics.keys()).join(', '));
                                        }
                                        this.emit(this.onConnect);
                                        resolve();
                                        return [2 /*return*/];
                                }
                            });
                        }); };
                        _this._socket.onmessage = function (_a) {
                            var data = _a.data;
                            _this._receiveMessage(data.toString());
                        };
                        // The following empty error callback needs to exist so connection errors are passed down to `onclose` down below - otherwise the process just crashes instead
                        _this._socket.onerror = function () { };
                        _this._socket.onclose = function (_a) {
                            var wasClean = _a.wasClean, code = _a.code, reason = _a.reason;
                            if (_this._pingCheckTimer) {
                                clearInterval(_this._pingCheckTimer);
                            }
                            if (_this._pingTimeoutTimer) {
                                clearTimeout(_this._pingTimeoutTimer);
                            }
                            _this._socket = undefined;
                            _this._connected = false;
                            _this._connecting = false;
                            var wasInitialConnect = _this._initialConnect;
                            _this._initialConnect = false;
                            _this.emit(_this.onDisconnect, !wasClean && !_this._manualDisconnect);
                            if (!wasClean) {
                                if (_this._manualDisconnect) {
                                    _this._manualDisconnect = false;
                                    _this._logger.info('Successfully disconnected');
                                }
                                else {
                                    _this._logger.err("Connection unexpectedly closed: [" + code + "] " + reason);
                                    if (wasInitialConnect) {
                                        reject();
                                    }
                                    if (!_this._retryDelayGenerator) {
                                        _this._retryDelayGenerator = BasicPubSubClient._getReconnectWaitTime();
                                    }
                                    var delay = _this._retryDelayGenerator.next().value;
                                    _this._logger.info("Reconnecting in " + delay + " seconds");
                                    _this._retryTimer = setTimeout(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                                        return [2 /*return*/, this.connect()];
                                    }); }); }, delay * 1000);
                                }
                            }
                        };
                    })];
            });
        });
    };
    /**
     * Disconnects from the PubSub interface.
     */
    BasicPubSubClient.prototype.disconnect = function () {
        this._logger.info('Disconnecting...');
        if (this._retryTimer) {
            clearInterval(this._retryTimer);
        }
        this._retryDelayGenerator = undefined;
        if (this._socket) {
            this._manualDisconnect = true;
            this._socket.close();
        }
    };
    /**
     * Reconnects to the PubSub interface.
     */
    BasicPubSubClient.prototype.reconnect = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.disconnect();
                        return [4 /*yield*/, this.connect()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    BasicPubSubClient.prototype._sendListen = function (topics, accessToken) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendNonced({
                        type: 'LISTEN',
                        data: {
                            topics: topics,
                            auth_token: accessToken
                        }
                    })];
            });
        });
    };
    BasicPubSubClient.prototype._sendUnlisten = function (topics) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._sendNonced({
                        type: 'UNLISTEN',
                        data: {
                            topics: topics
                        }
                    })];
            });
        });
    };
    BasicPubSubClient.prototype._resendListens = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var topicsByToken;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                topicsByToken = Array.from(this._topics.entries()).reduce(function (result, _a) {
                    var _b = tslib_1.__read(_a, 2), topic = _b[0], token = _b[1];
                    if (result.has(token)) {
                        result.get(token).push(topic);
                    }
                    else {
                        result.set(token, [topic]);
                    }
                    return result;
                }, new Map());
                return [2 /*return*/, Promise.all(Array.from(topicsByToken.entries()).map(function (_a) {
                        var _b = tslib_1.__read(_a, 2), token = _b[0], topics = _b[1];
                        return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_c) {
                            return [2 /*return*/, this._sendListen(topics, token)];
                        }); });
                    }))];
            });
        });
    };
    BasicPubSubClient.prototype._sendNonced = function (packet) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var nonce = Math.random()
                            .toString(16)
                            .slice(2);
                        _this._onResponse(function (recvNonce, error) {
                            if (recvNonce === nonce) {
                                if (error) {
                                    reject(new Error("Error sending nonced " + packet.type + " packet: " + error));
                                }
                                else {
                                    resolve();
                                }
                            }
                        });
                        packet.nonce = nonce;
                        _this._sendPacket(packet);
                    })];
            });
        });
    };
    BasicPubSubClient.prototype._receiveMessage = function (dataStr) {
        this._logger.debug2("Received message: " + dataStr);
        var data = JSON.parse(dataStr);
        switch (data.type) {
            case 'PONG': {
                this.emit(this._onPong);
                break;
            }
            case 'RECONNECT': {
                // tslint:disable-next-line:no-floating-promises
                this.reconnect();
                break;
            }
            case 'RESPONSE': {
                this.emit(this._onResponse, data.nonce, data.error);
                break;
            }
            case 'MESSAGE': {
                this.emit(this.onMessage, data.data.topic, JSON.parse(data.data.message));
                break;
            }
            default: {
                this._logger.warn("PubSub connection received unexpected message type: " + data.type);
            }
        }
    };
    BasicPubSubClient.prototype._sendPacket = function (data) {
        var dataStr = JSON.stringify(data);
        this._logger.debug2("Sending message: " + dataStr);
        if (this._socket && this._connected) {
            this._socket.send(dataStr);
        }
    };
    BasicPubSubClient.prototype._pingCheck = function () {
        var _this = this;
        var pingTime = Date.now();
        var pongListener = this._onPong(function () {
            var latency = Date.now() - pingTime;
            _this.emit(_this.onPong, latency, pingTime);
            _this._logger.debug1("Current latency: " + latency + "ms");
            if (_this._pingTimeoutTimer) {
                clearTimeout(_this._pingTimeoutTimer);
            }
            _this.removeListener(pongListener);
        });
        this._pingTimeoutTimer = setTimeout(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                this._logger.err('Ping timeout');
                this.removeListener(pongListener);
                return [2 /*return*/, this.reconnect()];
            });
        }); }, 10000);
        this._sendPacket({ type: 'PING' });
    };
    Object.defineProperty(BasicPubSubClient.prototype, "isConnecting", {
        /**
         * Checks whether the client is currently connecting to the server.
         */
        get: function () {
            return this._connecting;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BasicPubSubClient.prototype, "isConnected", {
        /**
         * Checks whether the client is currently connected to the server.
         */
        get: function () {
            return this._connected;
        },
        enumerable: true,
        configurable: true
    });
    BasicPubSubClient.prototype._startPingCheckTimer = function () {
        var _this = this;
        if (this._pingCheckTimer) {
            clearInterval(this._pingCheckTimer);
        }
        this._pingCheckTimer = setInterval(function () { return _this._pingCheck(); }, 60000);
    };
    // yes, this is just fibonacci with a limit
    BasicPubSubClient._getReconnectWaitTime = function () {
        var current, next;
        var _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    current = 0;
                    next = 1;
                    _b.label = 1;
                case 1:
                    if (!(current < 120)) return [3 /*break*/, 3];
                    return [4 /*yield*/, current];
                case 2:
                    _b.sent();
                    _a = tslib_1.__read([next, current + next], 2), current = _a[0], next = _a[1];
                    return [3 /*break*/, 1];
                case 3:
                    if (!true) return [3 /*break*/, 5];
                    return [4 /*yield*/, 120];
                case 4:
                    _b.sent();
                    return [3 /*break*/, 3];
                case 5: return [2 /*return*/];
            }
        });
    };
    tslib_1.__decorate([
        Decorators_1.NonEnumerable
    ], BasicPubSubClient.prototype, "_logger", void 0);
    tslib_1.__decorate([
        Decorators_1.NonEnumerable
    ], BasicPubSubClient.prototype, "_topics", void 0);
    return BasicPubSubClient;
}(typed_event_emitter_1.EventEmitter));
exports.default = BasicPubSubClient;
//# sourceMappingURL=BasicPubSubClient.js.map