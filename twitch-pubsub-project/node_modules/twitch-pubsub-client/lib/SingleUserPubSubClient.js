"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var twitch_1 = require("twitch");
var BasicPubSubClient_1 = require("./BasicPubSubClient");
var Decorators_1 = require("./Toolkit/Decorators");
var PubSubListener_1 = require("./PubSubListener");
var PubSubBitsMessage_1 = require("./Messages/PubSubBitsMessage");
var PubSubBitsBadgeUnlockMessage_1 = require("./Messages/PubSubBitsBadgeUnlockMessage");
var PubSubChatModActionMessage_1 = require("./Messages/PubSubChatModActionMessage");
var PubSubSubscriptionMessage_1 = require("./Messages/PubSubSubscriptionMessage");
var PubSubWhisperMessage_1 = require("./Messages/PubSubWhisperMessage");
var logger_1 = require("@d-fischer/logger");
/**
 * A higher level PubSub client attached to a single user.
 */
var SingleUserPubSubClient = /** @class */ (function () {
    /**
     * Creates a new Twitch PubSub client.
     *
     * @expandParams
     */
    function SingleUserPubSubClient(_a) {
        var _this = this;
        var twitchClient = _a.twitchClient, pubSubClient = _a.pubSubClient, _b = _a.logLevel, logLevel = _b === void 0 ? logger_1.LogLevel.WARNING : _b;
        this._listeners = new Map();
        this._twitchClient = twitchClient;
        this._pubSubClient = pubSubClient || new BasicPubSubClient_1.default(logLevel);
        this._pubSubClient.onMessage(function (topic, messageData) {
            var e_1, _a;
            var _b = tslib_1.__read(topic.split('.')), type = _b[0], args = _b.slice(1);
            if (_this._listeners.has(type)) {
                var message = void 0;
                switch (type) {
                    case 'channel-bits-events-v2': {
                        message = new PubSubBitsMessage_1.default(messageData, _this._twitchClient);
                        break;
                    }
                    case 'channel-bits-badge-unlocks': {
                        message = new PubSubBitsBadgeUnlockMessage_1.default(messageData, _this._twitchClient);
                        break;
                    }
                    case 'channel-subscribe-events-v1': {
                        message = new PubSubSubscriptionMessage_1.default(messageData, _this._twitchClient);
                        break;
                    }
                    case 'chat_moderator_actions': {
                        message = new PubSubChatModActionMessage_1.default(messageData, args[1], _this._twitchClient);
                        break;
                    }
                    case 'whispers': {
                        message = new PubSubWhisperMessage_1.default(messageData, _this._twitchClient);
                        break;
                    }
                    default:
                        return;
                }
                try {
                    for (var _c = tslib_1.__values(_this._listeners.get(type)), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var listener = _d.value;
                        listener.call(message);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
    }
    /**
     * Adds a listener to bits events to the client.
     *
     * @param callback A function to be called when a bits event happens in the user's channel.
     *
     * It receives a {@PubSubBitsMessage} object.
     */
    SingleUserPubSubClient.prototype.onBits = function (callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._addListener('channel-bits-events-v2', callback, 'bits:read')];
            });
        });
    };
    /**
     * Adds a listener to bits badge unlock events to the client.
     *
     * @param callback A function to be called when a bits event happens in the user's channel.
     *
     * It receives a {@PubSubBitsBadgeUnlockMessage} object.
     */
    SingleUserPubSubClient.prototype.onBitsBadgeUnlock = function (callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._addListener('channel-bits-badge-unlocks', callback)];
            });
        });
    };
    /**
     * Adds a listener to subscription events to the client.
     *
     * @param callback A function to be called when a subscription event happens in the user's channel.
     *
     * It receives a {@PubSubSubscriptionMessage} object.
     */
    SingleUserPubSubClient.prototype.onSubscription = function (callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._addListener('channel-subscribe-events-v1', callback, 'channel_subscriptions')];
            });
        });
    };
    /**
     * Adds a listener to whisper events to the client.
     *
     * @param callback A function to be called when a whisper event is sent to the user.
     *
     * It receives a {@PubSubWhisperMessage} object.
     */
    SingleUserPubSubClient.prototype.onWhisper = function (callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._addListener('whispers', callback, 'whispers:read')];
            });
        });
    };
    /**
     * Adds a listener to mod action events to the client.
     *
     * @param channelId The ID of the channel to listen to.
     * @param callback A function to be called when a mod action event is sent to the user.
     *
     * It receives a {@PubSubChatModActionMessage} object.
     */
    SingleUserPubSubClient.prototype.onModAction = function (channelId, callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                return [2 /*return*/, this._addListener('chat_moderator_actions', callback, undefined, twitch_1.extractUserId(channelId))];
            });
        });
    };
    /**
     * Removes a listener from the client.
     *
     * @param listener A listener returned by one of the `add*Listener` methods.
     */
    SingleUserPubSubClient.prototype.removeListener = function (listener) {
        if (this._listeners.has(listener.type)) {
            var newListeners = this._listeners.get(listener.type).filter(function (l) { return l !== listener; });
            if (newListeners.length === 0) {
                this._listeners.delete(listener.type);
                // tslint:disable-next-line:no-floating-promises
                this._pubSubClient.unlisten(listener.type + "." + listener.userId);
            }
            else {
                this._listeners.set(listener.type, newListeners);
            }
        }
    };
    SingleUserPubSubClient.prototype._getUserData = function (scope) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var tokenData, accessToken, tokenInfo, userId;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._twitchClient._config.authProvider.getAccessToken(scope)];
                    case 1:
                        tokenData = _a.sent();
                        if (!tokenData) return [3 /*break*/, 3];
                        accessToken = tokenData.accessToken;
                        return [4 /*yield*/, this._twitchClient.getTokenInfo()];
                    case 2:
                        tokenInfo = _a.sent();
                        _a.label = 3;
                    case 3:
                        if (!(!(tokenInfo && tokenInfo.valid) && this._twitchClient._config.authProvider.refresh)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this._twitchClient._config.authProvider.refresh()];
                    case 4:
                        accessToken = (_a.sent()).accessToken;
                        return [4 /*yield*/, this._twitchClient.getTokenInfo()];
                    case 5:
                        tokenInfo = _a.sent();
                        _a.label = 6;
                    case 6:
                        if (!(tokenInfo && tokenInfo.valid) || !accessToken) {
                            throw new Error('PubSub authentication failed');
                        }
                        userId = tokenInfo.userId;
                        return [2 /*return*/, { userId: userId, accessToken: accessToken }];
                }
            });
        });
    };
    SingleUserPubSubClient.prototype._addListener = function (type, callback, scope) {
        var additionalParams = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            additionalParams[_i - 3] = arguments[_i];
        }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, userId, accessToken, listener;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._pubSubClient.connect()];
                    case 1:
                        _b.sent();
                        return [4 /*yield*/, this._getUserData(scope)];
                    case 2:
                        _a = _b.sent(), userId = _a.userId, accessToken = _a.accessToken;
                        listener = new PubSubListener_1.default(type, userId, callback, this);
                        if (!this._listeners.has(type)) return [3 /*break*/, 3];
                        this._listeners.get(type).push(listener);
                        return [3 /*break*/, 5];
                    case 3:
                        this._listeners.set(type, [listener]);
                        return [4 /*yield*/, this._pubSubClient.listen(tslib_1.__spread([type, userId], additionalParams).join('.'), accessToken)];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5: return [2 /*return*/, listener];
                }
            });
        });
    };
    tslib_1.__decorate([
        Decorators_1.NonEnumerable
    ], SingleUserPubSubClient.prototype, "_twitchClient", void 0);
    tslib_1.__decorate([
        Decorators_1.NonEnumerable
    ], SingleUserPubSubClient.prototype, "_pubSubClient", void 0);
    return SingleUserPubSubClient;
}());
exports.default = SingleUserPubSubClient;
//# sourceMappingURL=SingleUserPubSubClient.js.map